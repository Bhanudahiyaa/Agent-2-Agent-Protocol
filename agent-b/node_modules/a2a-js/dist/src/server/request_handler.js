import { TaskNotFoundError, OperationNotSupportedError, } from "../types/index.js";
import { InMemoryTaskStore } from "./task_store.js";
/**
 * Default implementation of A2ARequestHandler
 */
export class DefaultA2ARequestHandler {
    /**
     * Create a DefaultA2ARequestHandler
     *
     * @param agentExecutor - Agent executor
     * @param taskStore - Task store (optional, defaults to InMemoryTaskStore)
     */
    constructor(agentExecutor, taskStore) {
        this.backgroundTasks = new Set();
        this.agentExecutor = agentExecutor;
        this.taskStore = taskStore || new InMemoryTaskStore();
    }
    /**
     * Build an error response
     *
     * @param requestId - Request ID
     * @param error - Error
     * @returns JSON-RPC error response
     */
    _buildErrorResponse(requestId, error) {
        return {
            jsonrpc: "2.0",
            id: requestId,
            error: error,
        };
    }
    /**
     * Append a message to a task
     *
     * @param messageSendParams - Message send parameters
     * @param task - Task to append the message to
     */
    _appendMessageToTask(messageSendParams, task) {
        if (task) {
            task.history = task.history || [];
            task.history.push(messageSendParams.message);
            task.metadata = task.metadata || {};
            task.metadata.updatedAt = new Date().toISOString();
        }
    }
    /**
     * Set up a server-sent event consumer
     *
     * @param task - Task (optional)
     * @param request - Send message streaming request
     * @returns AsyncGenerator yielding streaming responses
     */
    async *_setupSSEConsumer(task, request) {
        const messageSendParams = request.params;
        // Append the message to the task if it exists
        this._appendMessageToTask(messageSendParams, task);
        // Generate streaming responses
        try {
            const responseStream = this.agentExecutor.onMessageStream(request, task);
            for await (const response of responseStream) {
                // Check if the response contains a successful result with a task
                if ("result" in response &&
                    response.result &&
                    typeof response.result === "object" &&
                    "taskId" in response.result) {
                    // Save the task - cast to unknown first to avoid TypeScript error
                    await this.taskStore.save(response.result);
                }
                yield response;
            }
        }
        catch (error) {
            console.error("Error in streaming response:", error);
            yield {
                jsonrpc: "2.0",
                id: request.id,
                error: {
                    code: -32603,
                    message: `Internal error: ${error}`,
                },
            };
        }
    }
    /**
     * Handle get task request
     *
     * @param request - Get task request
     * @returns Promise resolving to the get task response
     */
    async onGetTask(request) {
        const taskQueryParams = request.params;
        const task = await this.taskStore.get(taskQueryParams.id);
        if (!task) {
            return {
                jsonrpc: "2.0",
                id: request.id,
                error: new TaskNotFoundError(),
            };
        }
        return {
            jsonrpc: "2.0",
            id: request.id,
            result: task,
        };
    }
    /**
     * Handle cancel task request
     *
     * @param request - Cancel task request
     * @returns Promise resolving to the cancel task response
     */
    async onCancelTask(request) {
        const taskIdParams = request.params;
        const task = await this.taskStore.get(taskIdParams.id);
        if (!task) {
            return {
                jsonrpc: "2.0",
                id: request.id,
                error: new TaskNotFoundError(),
            };
        }
        const response = await this.agentExecutor.onCancel(request, task);
        if ("result" in response) {
            await this.taskStore.save(response.result);
        }
        return response;
    }
    /**
     * Handle message send request
     *
     * @param request - Send message request
     * @returns Promise resolving to the send message response
     */
    async onMessageSend(request) {
        const messageSendParams = request.params;
        let task;
        // Use the id from messageSendParams (TaskSendParams) instead of message.taskId
        // Message does not have a taskId property; the task id is in the params
        if (messageSendParams.id) {
            task = await this.taskStore.get(messageSendParams.id);
            this._appendMessageToTask(messageSendParams, task);
        }
        const response = await this.agentExecutor.onMessageSend(request, task);
        if ("result" in response &&
            response.result &&
            typeof response.result === "object" &&
            "taskId" in response.result) {
            // Cast to unknown first to avoid TypeScript error when result might be a Task
            await this.taskStore.save(response.result);
        }
        return response;
    }
    /**
     * Handle message send stream request
     *
     * @param request - Send message streaming request
     * @returns AsyncGenerator yielding streaming responses
     */
    async *onMessageSendStream(request) {
        const messageSendParams = request.params;
        let task;
        // Use the id from messageSendParams (TaskSendParams) instead of message.taskId
        if (messageSendParams.id) {
            task = await this.taskStore.get(messageSendParams.id);
        }
        yield* this._setupSSEConsumer(task, request);
    }
    /**
     * Handle set task push notification config request
     *
     * @param request - Set task push notification config request
     * @returns Promise resolving to the set task push notification config response
     */
    async onSetTaskPushNotification(request) {
        return {
            jsonrpc: "2.0",
            id: request.id,
            error: new OperationNotSupportedError(),
        };
    }
    /**
     * Handle get task push notification config request
     *
     * @param request - Get task push notification config request
     * @returns Promise resolving to the get task push notification config response
     */
    async onGetTaskPushNotification(request) {
        return {
            jsonrpc: "2.0",
            id: request.id,
            error: new OperationNotSupportedError(),
        };
    }
    /**
     * Handle task resubscription request
     *
     * @param request - Task resubscription request
     * @returns AsyncGenerator yielding streaming responses
     */
    async *onResubscribeToTask(request) {
        const taskIdParams = request.params;
        const task = await this.taskStore.get(taskIdParams.id);
        if (!task) {
            yield {
                jsonrpc: "2.0",
                id: request.id,
                error: new TaskNotFoundError(),
            };
            return;
        }
        yield* this.agentExecutor.onResubscribe(request, task);
    }
}
//# sourceMappingURL=request_handler.js.map