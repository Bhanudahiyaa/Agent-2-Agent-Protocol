import express from "express";
import cors from "cors";
import bodyParser from "body-parser";
/**
 * Express application for handling A2A requests
 */
export class A2AApplication {
    /**
     * Create a A2AApplication
     *
     * @param agentCard - Agent card
     * @param requestHandler - Request handler
     */
    constructor(agentCard, requestHandler) {
        this.agentCard = agentCard;
        this.requestHandler = requestHandler;
    }
    /**
     * Build an Express application
     *
     * @returns Express application
     */
    build() {
        const app = express();
        // Middleware
        app.use(cors());
        app.use(bodyParser.json({ limit: "50mb" }));
        // Agent card route
        app.get("/.well-known/agent.json", (_req, res) => {
            res.json(this.agentCard);
        });
        // Main A2A endpoint
        app.post("/", (req, res) => {
            const jsonRpcRequest = req.body;
            // Store reference to this for use in async functions
            const self = this;
            // Handle different methods
            try {
                switch (jsonRpcRequest.method) {
                    case "message/send":
                        self.requestHandler
                            .onMessageSend(jsonRpcRequest)
                            .then((messageResponse) => {
                            res.json(messageResponse);
                        })
                            .catch((error) => {
                            handleError(error);
                        });
                        break;
                    case "message/sendStream":
                        res.setHeader("Content-Type", "text/event-stream");
                        res.setHeader("Cache-Control", "no-cache");
                        res.setHeader("Connection", "keep-alive");
                        // Handle streaming
                        (async () => {
                            try {
                                console.log("Starting SSE stream");
                                const sseGenerator = self.requestHandler.onMessageSendStream(jsonRpcRequest);
                                for await (const chunk of sseGenerator) {
                                    if (res.writableEnded) {
                                        console.log("Response already ended");
                                        break;
                                    }
                                    console.log("Sending SSE chunk:", JSON.stringify(chunk));
                                    res.write(`data: ${JSON.stringify(chunk)}\n\n`);
                                }
                                if (!res.writableEnded) {
                                    console.log("Sending end event and closing connection");
                                    res.write("event: end\ndata: {}\n\n");
                                    res.end();
                                }
                            }
                            catch (error) {
                                console.error("Error in SSE stream:", error);
                                handleError(error);
                            }
                        })();
                        break;
                    case "tasks/get":
                        self.requestHandler
                            .onGetTask(jsonRpcRequest)
                            .then((taskResponse) => {
                            res.json(taskResponse);
                        })
                            .catch((error) => {
                            handleError(error);
                        });
                        break;
                    case "tasks/cancel":
                        self.requestHandler
                            .onCancelTask(jsonRpcRequest)
                            .then((cancelResponse) => {
                            res.json(cancelResponse);
                        })
                            .catch((error) => {
                            handleError(error);
                        });
                        break;
                    case "tasks/pushNotificationConfig/set":
                        self.requestHandler
                            .onSetTaskPushNotification(jsonRpcRequest)
                            .then((setPushResponse) => {
                            res.json(setPushResponse);
                        })
                            .catch((error) => {
                            handleError(error);
                        });
                        break;
                    case "tasks/pushNotificationConfig/get":
                        self.requestHandler
                            .onGetTaskPushNotification(jsonRpcRequest)
                            .then((getPushResponse) => {
                            res.json(getPushResponse);
                        })
                            .catch((error) => {
                            handleError(error);
                        });
                        break;
                    case "tasks/resubscribe":
                        res.setHeader("Content-Type", "text/event-stream");
                        res.setHeader("Cache-Control", "no-cache");
                        res.setHeader("Connection", "keep-alive");
                        // Handle streaming resubscription
                        (async () => {
                            try {
                                const resubscribeGenerator = self.requestHandler.onResubscribeToTask(jsonRpcRequest);
                                for await (const chunk of resubscribeGenerator) {
                                    if (res.writableEnded)
                                        break;
                                    res.write(`data: ${JSON.stringify(chunk)}\n\n`);
                                }
                                if (!res.writableEnded) {
                                    res.write("event: end\ndata: {}\n\n");
                                    res.end();
                                }
                            }
                            catch (error) {
                                handleError(error);
                            }
                        })();
                        break;
                    case "tasks/send":
                        self.requestHandler
                            .onMessageSend(jsonRpcRequest)
                            .then((messageResponse) => {
                            res.json(messageResponse);
                        })
                            .catch((error) => {
                            handleError(error);
                        });
                        break;
                    case "tasks/sendSubscribe":
                        res.setHeader("Content-Type", "text/event-stream");
                        res.setHeader("Cache-Control", "no-cache");
                        res.setHeader("Connection", "keep-alive");
                        (async () => {
                            try {
                                const sseGenerator = self.requestHandler.onMessageSendStream(jsonRpcRequest);
                                for await (const chunk of sseGenerator) {
                                    if (res.writableEnded)
                                        break;
                                    res.write(`data: ${JSON.stringify(chunk)}\n\n`);
                                }
                                if (!res.writableEnded) {
                                    res.write("event: end\ndata: {}\n\n");
                                    res.end();
                                }
                            }
                            catch (error) {
                                handleError(error);
                            }
                        })();
                        break;
                    default:
                        res.status(400).json({
                            jsonrpc: "2.0",
                            id: jsonRpcRequest.id,
                            error: {
                                code: -32601,
                                message: "Method not found",
                            },
                        });
                }
            }
            catch (error) {
                handleError(error);
            }
            // Error handling helper
            function handleError(error) {
                console.error("Error handling request:", error);
                if (!res.headersSent) {
                    res.status(500).json({
                        jsonrpc: "2.0",
                        id: jsonRpcRequest.id,
                        error: {
                            code: -32603,
                            message: `Internal error: ${error}`,
                        },
                    });
                }
            }
        });
        return app;
    }
}
//# sourceMappingURL=app.js.map